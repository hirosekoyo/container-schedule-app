要件定義書 Ver.4.0 (Final)：コンテナ船荷役予定管理アプリ
目次
アプリ概要
機能要件
非機能要件
開発・技術要件
データベース設計 (構成SQL)
Supabase DB関数 (構成SQL)
環境変数設定
プロジェクトディレクトリ構成
1. アプリ概要
アプリ名: コンテナ船荷役予定管理アプリ
目的: 手作業で行われているコンテナ船の荷役予定作成・管理業務をデジタル化し、効率化を図る。関係者がPCからリアルタイムに最新の予定を確認・編集できる環境を構築する。
利用者: 荷役機器を管理する港湾管理会社の担当者。
2. 機能要件
日付ごとの予定を表示・編集するメイン画面。初回表示の高速化のため、ページ本体はサーバーコンポーネントとしてデータ取得を行い、インタラクティブなUI部分はクライアントコンポーネント(DashboardClient)に分離したハイブリッドレンダリング方式を採用。
ページナビゲーション (DateNavigator):
表示日付の前日・翌日に移動するための矢印ボタンを配置。
現在の日付をクリックするとカレンダー(Popover + Calendar)が表示され、任意の日付にジャンプできる。
ページ遷移時、URLクエリパラメータに含まれるimportIdを維持する。
データインポートページへのリンクボタンと、印刷プレビューを開くボタンを配置。
ヘッダー情報エリア (DashboardHeader):
選択日付の「日付」「当直者」「サポート者」を表示。
カード全体をクリックすると、当直者、風速、メモ情報を編集するためのモーダル(EditDailyReportDialog)が表示される。風速入力には、リアルタイムで反映される一括入力機能も備える。
船舶図エリア (GanttChart):
縦軸: 0:00 〜 翌2:00。
横軸: ビット番号33〜64。画面幅に応じて動的に拡縮する（レスポンシブ対応）。
ビット番号の上部に、クレーンの止め位置を示す静的なボックスを表示。これも横軸に連動して拡縮する。
各船舶予定を矩形ブロックとして表示。船体が33ビット未満にかかる予定は、左端を33ビットに揃えて描画する。
各ブロッククリックで予定編集モーダル(EditScheduleDialog)が開く。
差分ハイライト: インポート直後は、以下のルールで色分け表示される。
赤色: last_import_idがページの最新IDと異なる（今回のインポートに含まれなかった）「削除候補」の予定。
黄色: last_import_idが最新で、かつchanged_fieldsにデータがある「内容が変更された」予定。
荷役予定詳細テーブルエリア (ScheduleTable):
表示順は、**第1キー: 岸壁 (昇順)、第2キー: 着岸時間 (昇順)**でDBから取得・表示。
時刻表示: schedule_dateと着岸・離岸・荷役開始の日付が異なる場合、日付と時刻を2段で表示。
各行クリックで予定編集モーダルが開く。ゴミ箱アイコンクリックで予定を削除。
最終行に「新規作成行」を常設し、クリックで空の予定編集モーダルが開く。
差分ハイライト: ガントチャートと同様のルールに加え、changed_fieldsに含まれるフィールドのセル単位でのハイライトも行う。
予定編集モーダル (EditScheduleDialog):
モード: 既存の予定をクリックした場合は「編集モード」、新規作成行をクリックした場合は「新規作成モード」で開く。
編集対象: schedules（船舶情報）とcargo_operations（荷役作業）の両方を編集可能。
UI/UX:
日時入力は、カレンダーと15分刻みのセレクトボックスを組み合わせたカスタムコンポーネント(DateTimePicker)を採用。
着岸位置（おもて・とも）はビット表記(33+15)で入力可能。
荷役作業行は動的に追加・削除可能。「GC運転」の初期値は、船舶情報の「プランナ」から自動入力される。
データ処理: 更新ボタン押下時、備考(remarks)を除く主要フィールドからdata_hashを再計算し、last_import_idを最新化、changed_fieldsをNULLにリセットしてDBに保存する。
メモ編集エリア (MemoEdit):
daily_reportsテーブルのmemoフィールドを表示・編集できる独立したコンポーネント。
目的: 複数日分の船舶予定テキストを一括で解析し、DBに登録する。
処理フロー:
データ分割: テキストを「連絡先」行を区切りとして個別の船舶データブロックに分割。
データ抽出・加工:
船名（行頭の数字や◆は除去）、着岸・離岸日時、着岸位置などを抽出。
船の中心点のビット位置から、岸壁番号 (berth_number) を自動判定する（45.5未満:6, 57.5未満:7, それ以上:8）。
remarksを除く主要フィールドを元に**連結文字列 (data_hash)**を作成。
今回のインポートを識別する**ユニークID (last_import_id)**を生成。
日をまたぐ予定は、滞在日数分のレコードに複製。
データベース登録: DB関数 upsert_schedules_with_check を呼び出す。
リダイレクト: 処理完了後、インポート作業日の翌日のダッシュボードに、importIdを付けてリダイレクトする。
ダッシュボードの「印刷」ボタンから新しいタブで開かれる、A4縦向きに最適化されたページ。
レイアウト: 通常画面の DashboardClient コンポーネントを、CSS transform: scale() を使ってA4用紙一枚に収まるように縮小して表示する。
非表示要素: 日付ナビゲーションやインポートボタンなどの操作UIは非表示にする。
3. 非機能要件
権限管理: 開発中は認証なし。
レスポンシブデザイン: PC（通常画面）とA4用紙（印刷画面）に最適化。
4. 開発・技術要件
データベース: Supabase (PostgreSQL)
技術スタック: Next.js (App Router), TypeScript, Tailwind CSS, Shadcn/ui, date-fns, date-fns-tz, crypto (Node.js)
5. データベース設計 (Ver.3.1)
5.1. schedules
code
SQL
CREATE TABLE public.schedules (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_date DATE NOT NULL,
  ship_name TEXT NOT NULL,
  berth_number INT NOT NULL,
  -- タイムゾーン情報を含まない日時。アプリケーション全体で日本時間として解釈・扱う。
  arrival_time TIMESTAMP WITHOUT TIME ZONE NOT NULL,
  departure_time TIMESTAMP WITHOUT TIME ZONE NOT NULL,
  arrival_side TEXT,
  bow_position_m NUMERIC NOT NULL,
  stern_position_m NUMERIC NOT NULL,
  planner_company TEXT,
  remarks TEXT,                         -- 船の予定全体に対する、手動で編集される備考
  data_hash TEXT,                       -- 備考を除く主要データの連結文字列。インポート時の差分検知に使用。
  last_import_id TEXT,                  -- データの鮮度を示すID。インポートごとに更新される。
  changed_fields JSONB,                 -- インポート時に変更があったフィールド名の配列。UIのハイライトに使用。
  created_at TIMESTAMPTZ DEFAULT now(),
  CONSTRAINT schedules_date_name_unique UNIQUE (schedule_date, ship_name)
);
5.2. cargo_operations
code
SQL
CREATE TABLE public.cargo_operations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_id BIGINT NOT NULL REFERENCES public.schedules(id) ON DELETE CASCADE,
  start_time TIMESTAMP WITHOUT TIME ZONE,
  crane_names TEXT,
  container_count INT,
  stevedore_company TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
5.3. daily_reports
code
SQL
CREATE TABLE public.daily_reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  report_date DATE NOT NULL UNIQUE,
  primary_staff TEXT,
  secondary_staff TEXT,
  support_staff TEXT,
  wind_speed_1 NUMERIC, wind_speed_2 NUMERIC,
  wind_speed_3 NUMERIC, wind_speed_4 NUMERIC,
  wind_speed_5 NUMERIC, wind_speed_6 NUMERIC,
  wind_speed_7 NUMERIC, wind_speed_8 NUMERIC,
  memo TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
6. Supabase DB関数 (構成SQL)
6.1. upsert_schedules_with_check (一括インポート用)
役割: 受け取ったスケジュールデータの配列を元に、高度なUPSERT処理を行う。
code
SQL
CREATE OR REPLACE FUNCTION public.upsert_schedules_with_check(schedules_data jsonb)
RETURNS TABLE(updated_count integer, inserted_count integer)
LANGUAGE plpgsql
AS $$
DECLARE
  new_schedule JSONB; existing_schedule RECORD; _updated_count INT := 0; _inserted_count INT := 0;
  old_values TEXT[]; new_values TEXT[];
  field_names TEXT[] := ARRAY['ship_name', 'berth_number', 'arrival_time', 'departure_time', 'arrival_side', 'bow_position_m', 'stern_position_m', 'planner_company'];
  changed_fields_array TEXT[]; i INT;
BEGIN
  FOR new_schedule IN SELECT * FROM jsonb_array_elements(schedules_data) LOOP
    SELECT * INTO existing_schedule FROM public.schedules WHERE schedule_date = (new_schedule->>'schedule_date')::DATE AND ship_name = (new_schedule->>'ship_name');
    
    IF existing_schedule IS NULL THEN
      -- --- 【ここからが修正箇所 (INSERT)】 ---
      INSERT INTO public.schedules (
        ship_name, berth_number, arrival_time, departure_time, arrival_side,
        bow_position_m, stern_position_m, planner_company, schedule_date,
        data_hash, last_import_id, changed_fields, remarks
      ) VALUES (
        new_schedule->>'ship_name', (new_schedule->>'berth_number')::INT, (new_schedule->>'arrival_time')::TIMESTAMP,
        (new_schedule->>'departure_time')::TIMESTAMP, new_schedule->>'arrival_side', (new_schedule->>'bow_position_m')::NUMERIC,
        (new_schedule->>'stern_position_m')::NUMERIC, new_schedule->>'planner_company', (new_schedule->>'schedule_date')::DATE,
        new_schedule->>'data_hash', new_schedule->>'last_import_id', 
        (new_schedule->'changed_fields')::JSONB, -- parserから渡されたchanged_fieldsを保存
        new_schedule->>'remarks'                 -- parserから渡されたremarksを保存
      );
      _inserted_count := _inserted_count + 1;
      -- --- 【ここまで】 ---
    ELSE
      IF existing_schedule.data_hash IS DISTINCT FROM (new_schedule->>'data_hash') THEN
        -- ... (変更があった場合の差分検知ロジックは変更なし)
        UPDATE public.schedules SET
          arrival_time = (new_schedule->>'arrival_time')::TIMESTAMP,
          -- ... (他のフィールド)
          data_hash = new_schedule->>'data_hash',
          last_import_id = new_schedule->>'last_import_id',
          changed_fields = to_jsonb(changed_fields_array),
          remarks = new_schedule->>'remarks' -- 【追加】remarksも更新
        WHERE id = existing_schedule.id;
        _updated_count := _updated_count + 1;
      ELSE
        -- 内容が変更されていない場合
        UPDATE public.schedules SET
          last_import_id = new_schedule->>'last_import_id',
          changed_fields = (new_schedule->'changed_fields')::JSONB, -- 【修正】parserからのchanged_fieldsで上書き
          remarks = new_schedule->>'remarks' -- 【追加】remarksも更新
        WHERE id = existing_schedule.id;
        _updated_count := _updated_count + 1;
      END IF;
    END IF;
  END LOOP;
  RETURN QUERY SELECT _updated_count, _inserted_count;
END;
$$;
6.2. create_schedule_with_operations (手動での新規作成用)
役割: 1件のスケジュールと荷役作業をトランザクションでINSERTする。
code
SQL
CREATE OR REPLACE FUNCTION public.create_schedule_with_operations(schedule_data jsonb, operations_data jsonb)
RETURNS bigint LANGUAGE plpgsql AS $$
DECLARE new_schedule_id bigint; op jsonb;
BEGIN
  INSERT INTO public.schedules (ship_name, berth_number, arrival_time, departure_time, arrival_side, bow_position_m, stern_position_m, planner_company, schedule_date, data_hash, last_import_id, changed_fields, remarks)
  VALUES (schedule_data->>'ship_name', (schedule_data->>'berth_number')::INT, (schedule_data->>'arrival_time')::TIMESTAMP, (schedule_data->>'departure_time')::TIMESTAMP, schedule_data->>'arrival_side', (schedule_data->>'bow_position_m')::NUMERIC, (schedule_data->>'stern_position_m')::NUMERIC, schedule_data->>'planner_company', (schedule_data->>'schedule_date')::DATE, schedule_data->>'data_hash', schedule_data->>'last_import_id', NULL, schedule_data->>'remarks')
  RETURNING id INTO new_schedule_id;
  IF operations_data IS NOT NULL AND jsonb_array_length(operations_data) > 0 THEN
    FOR op IN SELECT * FROM jsonb_array_elements(operations_data) LOOP
      INSERT INTO public.cargo_operations (schedule_id, start_time, crane_names, container_count, stevedore_company)
      VALUES (new_schedule_id, (op->>'start_time')::TIMESTAMP, op->>'crane_names', (op->>'container_count')::INT, op->>'stevedore_company');
    END LOOP;
  END IF;
  RETURN new_schedule_id;
END;
$$;
6.3. update_schedule_with_operations (手動での更新用)
役割: 1件のスケジュールと荷役作業をトランザクションでUPDATEする。手動更新は「確認済み」とみなし、changed_fieldsをNULLにリセットする。
code
SQL
CREATE OR REPLACE FUNCTION public.update_schedule_with_operations(p_schedule_id bigint, schedule_data jsonb, operations_data jsonb)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE op jsonb;
BEGIN
  UPDATE public.schedules SET
    ship_name = schedule_data->>'ship_name', arrival_time = (schedule_data->>'arrival_time')::TIMESTAMP, departure_time = (schedule_data->>'departure_time')::TIMESTAMP,
    arrival_side = schedule_data->>'arrival_side', bow_position_m = (schedule_data->>'bow_position_m')::NUMERIC, stern_position_m = (schedule_data->>'stern_position_m')::NUMERIC,
    planner_company = schedule_data->>'planner_company', berth_number = (schedule_data->>'berth_number')::INT, remarks = schedule_data->>'remarks',
    data_hash = schedule_data->>'data_hash', last_import_id = schedule_data->>'last_import_id', changed_fields = NULL
  WHERE id = p_schedule_id;
  DELETE FROM public.cargo_operations WHERE schedule_id = p_schedule_id;
  IF operations_data IS NOT NULL AND jsonb_array_length(operations_data) > 0 THEN
    FOR op IN SELECT * FROM jsonb_array_elements(operations_data) LOOP
      INSERT INTO public.cargo_operations (schedule_id, start_time, crane_names, container_count, stevedore_company)
      VALUES (p_schedule_id, (op->>'start_time')::TIMESTAMP, op->>'crane_names', (op->>'container_count')::INT, op->>'stevedore_company');
    END LOOP;
  END IF;
END;
$$;
6.4. truncate_schedules_and_dependencies (データリセット用)
役割: schedulesとcargo_operationsを全件削除する。
code
SQL
CREATE OR REPLACE FUNCTION public.truncate_schedules_and_dependencies()
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  TRUNCATE TABLE public.schedules RESTART IDENTITY CASCADE;
END;
$$;
7. 環境変数設定
プロジェクトのルートディレクトリに.env.localファイルを作成し、以下の内容を記述する。値はSupabaseプロジェクトのダッシュボード（Settings > API）から取得する。
code
Code
NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
8. プロジェクトディレクトリ構成
code
Code
.
├── /app/
│   ├── /dashboard/
│   │   ├── /[date]/
│   │   │   └── page.tsx         # ダッシュボード (サーバーコンポーネント)
│   │   └── /import/
│   │       └── page.tsx         # 一括インポート (クライアントコンポーネント)
│   └── /print/
│       ├── /[date]/
│       │   ├── PrintPageClient.tsx # 印刷プレビュー (クライアントコンポーネント)
│       │   └── page.tsx         # 印刷データ取得 (サーバーコンポーネント)
│       ├── layout.tsx
│       └── print.css
│   ├── globals.css
│   └── layout.tsx
├── /src/
│   ├── /components/
│   │   ├── /ui/
│   │   │   └── Combobox.tsx
│   │   ├── DashboardClient.tsx
│   │   ├── DashboardHeader.tsx
│   │   ├── DateNavigator.tsx
│   │   ├── DateTimePicker.tsx
│   │   ├── EditDailyReportDialog.tsx
│   │   ├── EditScheduleDialog.tsx
│   │   ├── GanttChart.tsx
│   │   ├── MemoEdit.tsx
│   │   └── ScheduleTable.tsx
│   ├── /lib/
│   │   ├── /supabase/
│   │   │   ├── actions.ts
│   │   │   └── server.ts
│   │   ├── constants.ts
│   │   └── parser.ts
│   └── /types/
│       └── database.types.ts
├── next.config.js
└── package.json