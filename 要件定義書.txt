要件定義書 Ver.4.1 (最終FIX版)：コンテナ船荷役予定管理アプリ
1. アプリ概要
アプリ名: コンテナ船荷役予定管理アプリ
目的: 手作業で行われているコンテナ船の荷役予定作成・管理業務をデジタル化し、効率化を図る。関係者がPCからリアルタイムに最新の予定を確認・編集できる環境を構築する。
利用者: 荷役機器を管理する港湾管理会社の担当者。
2. 機能要件
日付ごとの予定を表示・編集するメイン画面。初回表示の高速化のため、ページ本体はサーバーコンポーネントとしてデータ取得を行い、インタラクティブなUI部分はクライアントコンポーネント(DashboardClient)に分離したハイブリッドレンダリング方式を採用。
ページナビゲーション (DateNavigator):
表示日付の前日・翌日に移動するための矢印ボタン。
現在の日付をクリックするとカレンダーが表示され、任意の日付にジャンプ可能。
ページ遷移時にimportIdをURLクエリパラメータで維持する。
ヘッダー情報エリア (DashboardHeader):
選択日付の「日付」「当直者」「サポート者」を表示。
ヘッダーカード全体をクリックすると、当直者、風速、メモ情報を編集するためのモーダル (EditDailyReportDialog) が開く。
風速入力には、リアルタイム反映される一括入力機能あり。
船舶図（ガントチャート）エリア (GanttChart):
縦軸: 時間（0:00 〜 翌2:00）。
横軸: ビット番号（33〜64）。画面幅に応じて動的に拡縮（レスポンシブ対応）。
ビット番号の上に、クレーン止め位置を表示。
各船舶予定を矩形ブロックで表示。船体が33ビット未満にかかる場合は左端を33ビットに揃える。
各ブロッククリックで予定編集モーダル (EditScheduleDialog) が開く。
差分ハイライト: インポート直後、last_import_idが最新でない場合は赤色、changed_fieldsにデータがある場合は黄色でハイライト表示。
荷役予定詳細テーブルエリア (ScheduleTable):
表示順: 第1キー: 岸壁 (昇順)、第2キー: 着岸時間 (昇順)。
時刻表示: schedule_dateと日付が異なる場合は、日付と時刻を2段表示。
各行クリックで予定編集モーダルが開く。ゴミ箱アイコンクリックで予定を削除。
最終行に「新規作成行」を常設。クリックで空の予定編集モーダルが開く。
メモ編集エリア (MemoEdit):
daily_reportsテーブルのmemoフィールドを表示・編集できる独立コンポーネント。
目的: 複数日分の船舶予定テキストを一括で解析し、DBに登録。
処理フロー:
テキスト入力: 専用ページでテキストエリアにデータを貼り付け。
データ分割: テキストを「連絡先」行を区切りとして分割。
データ抽出・加工: 船名（行頭数字・◆除去）、日時、着岸位置などを抽出。船の中心点からberth_numberを自動判定（45.5m未満:6, 57.5m未満:7, それ以上:8）。remarksを除く主要フィールドでdata_hashを計算。ユニークID(last_import_id)を生成。日またぎはレコード複製。
DB登録 (高度なUPSERT): DB関数 upsert_schedules_with_check を呼び出し。
新規: INSERT。changed_fieldsはNULL。
既存 & data_hash異なる: UPDATEし、changed_fieldsに変更があったフィールド名をJSONBで保存。
既存 & data_hash同じ: last_import_idのみUPDATEし、changed_fieldsをNULLにリセット。
リダイレクト: 完了後、インポート翌日のダッシュボードにimportIdを付けてリダイレクト。
ダッシュボードの「印刷」ボタンから開かれる、A4縦向きに最適化されたページ。
レイアウト: 通常画面のDashboardClientを、transform: scale()でA4用紙に収まるように縮小して表示。操作UI（日付ナビ、インポートボタン）は非表示。
3. 非機能要件
権限管理: 開発中は認証なし。
レスポンシブデザイン: PC（通常画面）とA4用紙（印刷画面）に最適化。
4. 開発・技術要件
データベース: Supabase (PostgreSQL)
技術スタック: Next.js (App Router), TypeScript, Tailwind CSS, Shadcn/ui, date-fns, date-fns-tz, crypto (Node.js)
5. データベース設計 (Ver.3.1)
5.1. schedules (船舶予定テーブル)
schedule_dateとship_nameの組み合わせでユニーク制約を持つ。
code
SQL
CREATE TABLE public.schedules (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_date DATE NOT NULL,
  ship_name TEXT NOT NULL,
  berth_number INT NOT NULL,
  arrival_time TIMESTAMP NOT NULL,      -- タイムゾーンなし日時 (JSTとして扱う)
  departure_time TIMESTAMP NOT NULL,    -- タイムゾーンなし日時 (JSTとして扱う)
  arrival_side TEXT,
  bow_position_m NUMERIC NOT NULL,
  stern_position_m NUMERIC NOT NULL,
  planner_company TEXT,
  remarks TEXT,                         -- 船の予定全体に対する、手動で編集される備考
  data_hash TEXT,                       -- 備考を除く主要データの連結文字列。インポート時の差分検知に使用。
  last_import_id TEXT,                  -- データの鮮度を示すID。インポートごとに更新される。
  changed_fields JSONB,                 -- インポート時に変更があったフィールド名の配列。UIのハイライトに使用。
  created_at TIMESTAMPTZ DEFAULT now()
);
5.2. cargo_operations (荷役予定テーブル)
code
SQL
CREATE TABLE public.cargo_operations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_id BIGINT NOT NULL REFERENCES public.schedules(id) ON DELETE CASCADE,
  start_time TIMESTAMP,                 -- タイムゾーンなし日時
  crane_names TEXT,
  container_count INT,
  stevedore_company TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
5.3. daily_reports (日次情報テーブル)
code
SQL
CREATE TABLE public.daily_reports (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  report_date DATE NOT NULL UNIQUE,
  primary_staff TEXT,
  secondary_staff TEXT,
  support_staff TEXT,
  wind_speed_1 NUMERIC, wind_speed_2 NUMERIC,
  wind_speed_3 NUMERIC, wind_speed_4 NUMERIC,
  wind_speed_5 NUMERIC, wind_speed_6 NUMERIC,
  wind_speed_7 NUMERIC, wind_speed_8 NUMERIC,
  memo TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
6. Supabase DB関数 (構成SQL)
6.1. upsert_schedules_with_check (一括インポート用)
役割: 受け取ったスケジュールデータの配列を元に、高度なUPSERT処理を行う。remarks と changed_fields を正しく処理する。
code
SQL
CREATE OR REPLACE FUNCTION public.upsert_schedules_with_check(schedules_data jsonb)
RETURNS TABLE(updated_count integer, inserted_count integer)
LANGUAGE plpgsql
AS $$
DECLARE
  new_schedule JSONB; existing_schedule RECORD; _updated_count INT := 0; _inserted_count INT := 0;
  old_values TEXT[]; new_values TEXT[];
  field_names TEXT[] := ARRAY['ship_name', 'berth_number', 'arrival_time', 'departure_time', 'arrival_side', 'bow_position_m', 'stern_position_m', 'planner_company'];
  changed_fields_array TEXT[]; i INT;
BEGIN
  FOR new_schedule IN SELECT * FROM jsonb_array_elements(schedules_data)
  LOOP
    SELECT * INTO existing_schedule FROM public.schedules WHERE schedule_date = (new_schedule->>'schedule_date')::DATE AND ship_name = (new_schedule->>'ship_name');
    
    IF existing_schedule IS NULL THEN
      INSERT INTO public.schedules (
        ship_name, berth_number, arrival_time, departure_time, arrival_side,
        bow_position_m, stern_position_m, planner_company, schedule_date,
        data_hash, last_import_id, changed_fields, remarks
      ) VALUES (
        new_schedule->>'ship_name', (new_schedule->>'berth_number')::INT, (new_schedule->>'arrival_time')::TIMESTAMP,
        (new_schedule->>'departure_time')::TIMESTAMP, new_schedule->>'arrival_side', (new_schedule->>'bow_position_m')::NUMERIC,
        (new_schedule->>'stern_position_m')::NUMERIC, new_schedule->>'planner_company', (new_schedule->>'schedule_date')::DATE,
        new_schedule->>'data_hash', new_schedule->>'last_import_id', (new_schedule->'changed_fields')::JSONB, new_schedule->>'remarks'
      );
      _inserted_count := _inserted_count + 1;
    ELSE
      IF existing_schedule.data_hash IS DISTINCT FROM (new_schedule->>'data_hash') THEN
        old_values := string_to_array(existing_schedule.data_hash, '|'); new_values := string_to_array(new_schedule->>'data_hash', '|'); changed_fields_array := ARRAY[]::TEXT[];
        FOR i IN 1..array_length(field_names, 1) LOOP IF old_values[i] IS DISTINCT FROM new_values[i] THEN changed_fields_array := array_append(changed_fields_array, field_names[i]); END IF; END LOOP;
        UPDATE public.schedules SET
          arrival_time = (new_schedule->>'arrival_time')::TIMESTAMP, departure_time = (new_schedule->>'departure_time')::TIMESTAMP,
          arrival_side = new_schedule->>'arrival_side', bow_position_m = (new_schedule->>'bow_position_m')::NUMERIC, stern_position_m = (new_schedule->>'stern_position_m')::NUMERIC,
          planner_company = new_schedule->>'planner_company', berth_number = (new_schedule->>'berth_number')::INT, remarks = new_schedule->>'remarks',
          data_hash = new_schedule->>'data_hash', last_import_id = new_schedule->>'last_import_id',
          changed_fields = CASE WHEN array_length(changed_fields_array, 1) > 0 THEN to_jsonb(changed_fields_array) ELSE NULL END
        WHERE id = existing_schedule.id;
        _updated_count := _updated_count + 1;
      ELSE
        UPDATE public.schedules SET
          last_import_id = new_schedule->>'last_import_id',
          changed_fields = NULL,
          remarks = new_schedule->>'remarks' -- 備考も更新対象に含める
        WHERE id = existing_schedule.id;
        _updated_count := _updated_count + 1;
      END IF;
    END IF;
  END LOOP;
  RETURN QUERY SELECT _updated_count, _inserted_count;
END;
$$;
6.2. create_schedule_with_operations (手動での新規作成用)
code
SQL
CREATE OR REPLACE FUNCTION public.create_schedule_with_operations(schedule_data jsonb, operations_data jsonb)
RETURNS bigint LANGUAGE plpgsql AS $$
DECLARE new_schedule_id bigint; op jsonb;
BEGIN
  INSERT INTO public.schedules (ship_name, berth_number, arrival_time, departure_time, arrival_side, bow_position_m, stern_position_m, planner_company, schedule_date, data_hash, last_import_id, changed_fields, remarks)
  VALUES (schedule_data->>'ship_name', (schedule_data->>'berth_number')::INT, (schedule_data->>'arrival_time')::TIMESTAMP, (schedule_data->>'departure_time')::TIMESTAMP, schedule_data->>'arrival_side', (schedule_data->>'bow_position_m')::NUMERIC, (schedule_data->>'stern_position_m')::NUMERIC, schedule_data->>'planner_company', (schedule_data->>'schedule_date')::DATE, schedule_data->>'data_hash', schedule_data->>'last_import_id', (schedule_data->'changed_fields')::JSONB, schedule_data->>'remarks')
  RETURNING id INTO new_schedule_id;
  IF operations_data IS NOT NULL AND jsonb_array_length(operations_data) > 0 THEN
    FOR op IN SELECT * FROM jsonb_array_elements(operations_data) LOOP
      INSERT INTO public.cargo_operations (schedule_id, start_time, crane_names, container_count, stevedore_company)
      VALUES (new_schedule_id, (op->>'start_time')::TIMESTAMP, op->>'crane_names', (op->>'container_count')::INT, op->>'stevedore_company');
    END LOOP;
  END IF;
  RETURN new_schedule_id;
END;
$$;
6.3. update_schedule_with_operations (手動での更新用)
code
SQL
CREATE OR REPLACE FUNCTION public.update_schedule_with_operations(p_schedule_id bigint, schedule_data jsonb, operations_data jsonb)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE op jsonb;
BEGIN
  UPDATE public.schedules SET
    ship_name = schedule_data->>'ship_name', arrival_time = (schedule_data->>'arrival_time')::TIMESTAMP, departure_time = (schedule_data->>'departure_time')::TIMESTAMP,
    arrival_side = schedule_data->>'arrival_side', bow_position_m = (schedule_data->>'bow_position_m')::NUMERIC, stern_position_m = (schedule_data->>'stern_position_m')::NUMERIC,
    planner_company = schedule_data->>'planner_company', berth_number = (schedule_data->>'berth_number')::INT,
    remarks = schedule_data->>'remarks',
    data_hash = schedule_data->>'data_hash', last_import_id = schedule_data->>'last_import_id', changed_fields = NULL
  WHERE id = p_schedule_id;
  DELETE FROM public.cargo_operations WHERE schedule_id = p_schedule_id;
  IF operations_data IS NOT NULL AND jsonb_array_length(operations_data) > 0 THEN
    FOR op IN SELECT * FROM jsonb_array_elements(operations_data) LOOP
      INSERT INTO public.cargo_operations (schedule_id, start_time, crane_names, container_count, stevedore_company)
      VALUES (p_schedule_id, (op->>'start_time')::TIMESTAMP, op->>'crane_names', (op->>'container_count')::INT, op->>'stevedore_company');
    END LOOP;
  END IF;
END;
$$;
6.4. truncate_schedules_and_dependencies (データリセット用)
code
SQL
CREATE OR REPLACE FUNCTION public.truncate_schedules_and_dependencies()
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  TRUNCATE TABLE public.schedules RESTART IDENTITY CASCADE;
END;
$$;

8. プロジェクトディレクトリ構成 (最終FIX版)
code
Code
.
├── /app/
│   ├── /dashboard/
│   │   ├── /[date]/
│   │   │   └── page.tsx         # 【サーバー】ダッシュボード本体。データ取得とUIコンテナの役割。
│   │   └── /import/
│   │       └── page.tsx         # 【クライアント】データ一括インポートページ。
│   └── /print/
│       ├── /[date]/
│       │   ├── PrintPageClient.tsx # 【クライアント】印刷プレビュー画面のレイアウトと印刷実行。
│       │   └── page.tsx         # 【サーバー】印刷用データの取得とクライアントへの引き渡し。
│       ├── layout.tsx           # 印刷ページ専用の最小限のHTMLレイアウト。
│       └── print.css            # 印刷専用のスタイルシート。
│   ├── globals.css              # アプリケーション全体のグローバルCSS。
│   └── layout.tsx               # アプリケーション全体のルートレイアウト。
├── /src/
│   ├── /components/
│   │   ├── /ui/                   # Shadcn/uiによって自動生成されるUIプリミティブコンポーネント。
│   │   │   └── Combobox.tsx     # 自由入力可能なカスタムコンボボックス。
│   │   ├── DashboardClient.tsx    # 【クライアント】ダッシュボードの主要UIをまとめるコンテナ。state管理も担当。
│   │   ├── DashboardHeader.tsx    # 【クライアント】日付、当直者、風速情報を表示するヘッダー。
│   │   ├── DateNavigator.tsx      # 【クライアント】日付遷移ボタンとカレンダーピッカー。
│   │   ├── DateTimePicker.tsx     # 【クライアント】日付と15分刻みの時刻を選択するカスタムUI。
│   │   ├── EditDailyReportDialog.tsx # 【クライアント】日時情報（当直者、風速、メモ）を編集するモーダル。
│   │   ├── EditScheduleDialog.tsx   # 【クライアント】船舶・荷役予定を編集・新規作成する高機能モーダル。
│   │   ├── GanttChart.tsx         # 【クライアント】船舶図（ガントチャート）を描画するレスポンシブコンポーネント。
│   │   ├── MemoEdit.tsx           # 【クライアント】日次メモを表示・編集する専用コンポーネント。
│   │   └── ScheduleTable.tsx      # 【クライアント】荷役予定詳細を表示するテーブル。
│   ├── /lib/
│   │   ├── /supabase/
│   │   │   ├── actions.ts       # 【サーバー】Supabaseと連携する全てのサーバーアクション（DB操作関数）。
│   │   │   └── server.ts        # サーバーコンポーネント/アクション用のSupabaseクライアントを生成するヘルパー。
│   │   ├── constants.ts         # アプリ全体で共有する定数（荷役会社リスト、クレーンリストなど）。
│   │   ├── coordinateConverter.ts # ビット表記とメートル座標を相互変換する計算ロジック。
│   │   └── parser.ts            # テキストデータを解析し、DB保存用のJSONに変換するロジック。
│   └── /types/
│       └── database.types.ts    # Supabase CLIによって自動生成される、DBスキーマのTypeScript型定義。
├── .env.local                     # Supabase接続情報などの環境変数を定義するファイル (Git管理外)。
├── next.config.js                 # Next.jsのプロジェクト設定ファイル。
└── package.json                   # プロジェクトの依存関係とスクリプトを定義するファイル。
各ファイルの概要説明
/app (ルーティングとページ)
/dashboard/[date]/page.tsx: URLの日付に基づいてデータを取得し、DashboardClientに渡すサーバーサイドの入り口。
/dashboard/import/page.tsx: テキストデータを貼り付けて一括インポートを行うUI。クリップボードからの貼り付けやデータリセット機能も持つ。
/print/[date]/page.tsx: 印刷用のデータを取得し、PrintPageClientに渡すサーバーサイドの入り口。
/print/[date]/PrintPageClient.tsx: 通常画面のレイアウトを縮小してA4プレビューとして表示し、印刷ダイアログを起動する役割を持つ。
/src/components (UIコンポーネント)
/ui/: Shadcn/uiによって生成された、ボタンやテーブルなどの基本的なUI部品。
DashboardClient.tsx: ダッシュボードの主要なクライアントサイドのロジック（モーダルの開閉管理など）を集約し、サーバーから受け取ったデータを各UIコンポーネントに渡す役割。
GanttChart.tsx: schedulesデータを受け取り、SVGやdiv要素を使って視覚的なガントチャートを描画する。レスポンシブな幅計算も内包。
ScheduleTable.tsx: schedulesデータを受け取り、詳細な情報をテーブル形式で表示する。行クリックやボタンクリックのイベントを持つ。
EditScheduleDialog.tsx: 新規作成と編集の両方を担う高機能モーダル。入力値のバリデーションや、更新時のデータ整形なども行う。
その他のコンポーネント: それぞれが特定の役割（日付選択、メモ編集など）を持つ、再利用可能なUI部品。
/src/lib (コアロジックとヘルパー)
/supabase/actions.ts: アプリケーションのバックエンドロジックの心臓部。 DBとのすべてのやり取り（読み取り、書き込み、更新、削除）は、このファイルに定義されたサーバーアクションを通じて行われる。
constants.ts: アプリケーション全体で共通して使用する静的なデータ（選択肢のリストや変換マップなど）を定義。変更が発生した場合、このファイルを編集するだけで済む。
coordinateConverter.ts: 港の物理的なビットとメートル座標を相互に変換するための、専門的かつ重要な計算ロジックをカプセル化。
parser.ts: テキストデータという非構造化データを、DBに保存可能な構造化データ（JSON）に変換する、ETL処理の「Extract, Transform」部分を担う。
/src/types (型定義)
database.types.ts: SupabaseのDBスキーマとアプリケーションのTypeScriptコードを繋ぐ架け橋。DBスキーマを変更した後は、必ずCLIでこのファイルを再生成する必要がある。